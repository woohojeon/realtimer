<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 발표 통역</title>
    <!-- Azure Speech SDK -->
    <script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            max-width: 750px;
            margin: 0 auto;
            padding: 0;
        }

        /* 헤더 */
        .header {
            background: #2c2c2c;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #404040;
        }

        .header h1 {
            font-size: 18px;
            font-weight: bold;
        }

        .status {
            font-size: 12px;
            font-weight: bold;
            color: #888888;
            animation: pulse 2s infinite;
        }

        .status.live {
            color: #4caf50;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* API 키 설정 */
        .api-settings {
            background: #333333;
            padding: 15px 20px;
            border-bottom: 2px solid #404040;
        }

        .api-settings.hidden {
            display: none;
        }

        .api-input-group {
            margin-bottom: 10px;
        }

        .api-input-group label {
            display: block;
            font-size: 11px;
            color: #888888;
            margin-bottom: 5px;
        }

        .api-input-group input {
            width: 100%;
            padding: 8px 12px;
            background: #2c2c2c;
            border: 1px solid #404040;
            color: #ffffff;
            border-radius: 4px;
            font-size: 12px;
        }

        .api-input-group input:focus {
            outline: none;
            border-color: #00bcd4;
        }

        .api-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* 컨트롤 버튼 */
        .controls {
            background: #1a1a1a;
            padding: 15px 20px;
            display: flex;
            gap: 10px;
            border-bottom: 2px solid #404040;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-start {
            background: #4caf50;
            color: white;
        }

        .btn-stop {
            background: #666666;
            color: white;
        }

        .btn-settings {
            background: #555555;
            color: white;
        }

        .btn-primary {
            background: #00bcd4;
            color: white;
        }

        .btn-secondary {
            background: #555555;
            color: white;
        }

        /* 설정 패널 */
        .settings-panel {
            background: #333333;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #404040;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-group label {
            font-size: 11px;
            color: #888888;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            padding: 6px 10px;
            background: #2c2c2c;
            border: 1px solid #404040;
            color: #ffffff;
            border-radius: 4px;
            font-size: 12px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* 자막 영역 */
        .subtitles {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #1a1a1a;
        }

        .subtitle-block {
            background: #333333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #00bcd4;
            font-size: 16px;
            line-height: 1.6;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .subtitle-recognizing {
            background: #2c2c2c;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #888888;
            font-size: 14px;
            font-style: italic;
            color: #ffffff;
            opacity: 0.8;
        }

        .subtitle-translating {
            background: #2c2c2c;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #00bcd4;
            font-size: 15px;
            color: #00bcd4;
        }

        .subtitle-streaming {
            background: #333333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
            font-size: 16px;
            line-height: 1.6;
            color: #ffffff;
        }

        .subtitle-temp {
            color: #888888;
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }

        /* 스크롤바 스타일 */
        .subtitles::-webkit-scrollbar {
            width: 8px;
        }

        .subtitles::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .subtitles::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        .subtitles::-webkit-scrollbar-thumb:hover {
            background: #555555;
        }

        /* 알림 메시지 */
        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff5722;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideInRight 0.3s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .alert.success {
            background: #4caf50;
        }

        .alert.info {
            background: #00bcd4;
        }

        /* 라이트 모드 */
        body.light-mode {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            color: #2D3748;
        }

        body.light-mode .header {
            background: #ffffff;
            border-bottom-color: #e2e8f0;
        }

        body.light-mode .header h1 {
            color: #2D3748;
        }

        body.light-mode .api-settings,
        body.light-mode .settings-panel {
            background: #ffffff;
            border-bottom-color: #e2e8f0;
        }

        body.light-mode .api-input-group label,
        body.light-mode .setting-group label {
            color: #718096;
        }

        body.light-mode .api-input-group input,
        body.light-mode .setting-group select,
        body.light-mode .setting-group input[type="number"] {
            background: #f7f8fc;
            border-color: #e2e8f0;
            color: #2D3748;
        }

        body.light-mode .controls {
            background: #f7f8fc;
            border-bottom-color: #e2e8f0;
        }

        body.light-mode .subtitles {
            background: #f7f8fc;
        }

        body.light-mode .subtitle-block {
            background: #ffffff;
            color: #2D3748;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        body.light-mode .subtitle-recognizing {
            background: #f0f1f5;
            color: #2D3748;
        }

        body.light-mode .subtitle-translating {
            background: #f0f1f5;
        }

        body.light-mode .subtitle-streaming {
            background: #ffffff;
            color: #2D3748;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        body.light-mode .subtitle-temp {
            color: #718096;
        }

        body.light-mode .subtitles::-webkit-scrollbar-track {
            background: #f7f8fc;
        }

        body.light-mode .subtitles::-webkit-scrollbar-thumb {
            background: #cbd5e0;
        }

        body.light-mode .subtitles::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

        body.light-mode #glossaryPanel,
        body.light-mode #glossaryPanel div[style*="background: #2c2c2c"],
        body.light-mode #glossaryList {
            background: #f0f1f5 !important;
        }

        body.light-mode #glossaryList div[style*="background: #1a1a1a"] {
            background: #ffffff !important;
        }

        /* 테마 토글 버튼 */
        .btn-theme {
            background: #333333;
            color: #888888;
            min-width: 60px;
        }

        body.light-mode .btn-theme {
            background: #e2e8f0;
            color: #718096;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 헤더 -->
        <div class="header">
            <h1>실시간 발표 통역</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div class="cache-stats" id="cacheStats" style="font-size: 11px; color: #888888;">
                    Cache: 0/0 (0%)
                </div>
                <div class="status" id="status">READY</div>
            </div>
        </div>

        <!-- API 키 설정 -->
        <div class="api-settings" id="apiSettings">
            <div class="api-input-group">
                <label>OpenAI API Key</label>
                <input type="password" id="openaiKeyInput" placeholder="sk-...">
            </div>
            <div class="api-input-group">
                <label>Azure Speech Key</label>
                <input type="password" id="azureKeyInput" placeholder="Azure Speech API Key">
            </div>
            <div class="api-input-group">
                <label>Azure Speech Region</label>
                <input type="text" id="azureRegionInput" placeholder="예: koreacentral, eastus">
            </div>
            <div class="api-actions">
                <button class="btn btn-primary" onclick="saveApiKeys()">저장하고 시작</button>
                <button class="btn btn-secondary" onclick="toggleApiSettings()">취소</button>
            </div>
        </div>

        <!-- 컨트롤 버튼 -->
        <div class="controls">
            <button class="btn btn-start" id="startBtn" onclick="startListening()">START</button>
            <button class="btn btn-stop" id="stopBtn" onclick="stopListening()" disabled>STOP</button>
            <button class="btn btn-settings" onclick="toggleApiSettings()">API 설정</button>
        </div>

        <!-- 설정 패널 -->
        <div class="settings-panel">
            <div class="setting-group">
                <label>Font Size</label>
                <input type="number" id="fontSize" value="16" min="12" max="28" step="2" onchange="updateFontSize()">
            </div>
            <div class="setting-group">
                <label>Translation Direction</label>
                <select id="direction" onchange="changeDirection()">
                    <option value="ko-to-en">KO → EN</option>
                    <option value="en-to-ko">EN → KO</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Real-time Translation</label>
                <div class="checkbox-group">
                    <input type="checkbox" id="realtimeMode" checked>
                    <span style="font-size: 11px; color: #888888;">Enable</span>
                </div>
            </div>
            <div class="setting-group">
                <button class="btn btn-secondary" onclick="toggleGlossary()" style="padding: 6px 12px; font-size: 11px;">
                    용어집 관리
                </button>
            </div>
            <div class="setting-group">
                <button class="btn btn-secondary" onclick="clearCache()" style="padding: 6px 12px; font-size: 11px;">
                    Clear Cache
                </button>
            </div>
            <div class="setting-group">
                <button class="btn btn-theme" id="themeBtn" onclick="toggleTheme()" style="padding: 6px 12px; font-size: 11px;">
                    Light
                </button>
            </div>
        </div>

        <!-- 용어집 관리 패널 -->
        <div class="api-settings hidden" id="glossaryPanel">
            <h3 style="font-size: 14px; margin-bottom: 10px; color: #ffffff;">전문용어 용어집</h3>
            <p style="font-size: 11px; color: #888888; margin-bottom: 10px;">
                STT가 잘못 인식한 용어를 정확한 전문용어로 교정합니다
            </p>
            <div class="api-input-group">
                <label>정확한 용어 (예: PRRSV)</label>
                <input type="text" id="glossaryTermInput" placeholder="PRRSV" style="width: 100%;">
            </div>
            <div class="api-input-group">
                <label>STT 발음들 (쉼표로 구분)</label>
                <input type="text" id="glossaryPronunciationInput" placeholder="피알알에스브이, 피알알에스비, prrsv" style="width: 100%;">
                <p style="font-size: 10px; color: #666; margin-top: 5px;">음성 인식이 인식할 수 있는 모든 발음을 입력하세요</p>
            </div>
            <div style="margin-top: 10px;">
                <button class="btn btn-primary" onclick="addGlossaryTerm()" style="width: 100%;">추가</button>
            </div>
            <div class="api-input-group" style="margin-top: 15px;">
                <label>저장된 용어</label>
                <div id="glossaryList" style="max-height: 250px; overflow-y: auto; background: #2c2c2c; padding: 10px; border-radius: 4px;">
                    <p style="color: #888888; font-size: 11px;">용어가 없습니다</p>
                </div>
            </div>
            <div class="api-actions">
                <button class="btn btn-secondary" onclick="toggleGlossary()">닫기</button>
            </div>
        </div>

        <!-- 자막 영역 -->
        <div class="subtitles" id="subtitles">
            <div class="subtitle-temp">발표 음성을 기다리는 중...</div>
        </div>
    </div>

    <script>
        // Azure Speech SDK 네임스페이스
        const SpeechSDK = window.SpeechSDK;

        // 전역 변수
        let recognizer = null;
        let isListening = false;
        let openaiKey = localStorage.getItem('openai_api_key') || '';
        let azureKey = localStorage.getItem('azure_speech_key') || '';
        let azureRegion = localStorage.getItem('azure_speech_region') || '';
        let history = [];
        let currentRecognizing = '';
        let currentTranslating = '';
        let currentStreamingText = '';
        let isStreaming = false;
        let translationDirection = 'ko-to-en';
        let realtimeMode = true;
        let debounceTimer = null;

        // 캐싱 시스템
        let translationCache = new Map();
        let cacheHits = 0;
        let cacheMisses = 0;
        const MAX_CACHE_SIZE = 200;

        // 용어집 시스템
        let glossary = new Map();
        loadGlossary();

        // 테마 시스템
        let isDarkMode = localStorage.getItem('theme') !== 'light';

        // 초기화
        window.onload = function() {
            if (openaiKey && azureKey && azureRegion) {
                document.getElementById('apiSettings').classList.add('hidden');
            }
            // 초기 캐시 통계 표시
            updateCacheStats();
            // 용어집 목록 표시
            updateGlossaryList();
            // 테마 적용
            applyTheme();
        };

        // 테마 토글
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            applyTheme();
        }

        // 테마 적용
        function applyTheme() {
            const body = document.body;
            const themeBtn = document.getElementById('themeBtn');

            if (isDarkMode) {
                body.classList.remove('light-mode');
                themeBtn.textContent = 'Light';
            } else {
                body.classList.add('light-mode');
                themeBtn.textContent = 'Dark';
            }
        }

        // API 키 저장
        async function saveApiKeys() {
            const openai = document.getElementById('openaiKeyInput').value.trim();
            const azure = document.getElementById('azureKeyInput').value.trim();
            const region = document.getElementById('azureRegionInput').value.trim();

            if (!openai || !azure || !region) {
                showAlert('모든 API 키와 지역을 입력해주세요', 'error');
                return;
            }

            // Azure Speech API 검증
            showAlert('Azure Speech API 검증 중...', 'info');
            const azureValid = await validateAzureSpeechAPI(azure, region);

            if (!azureValid.success) {
                showAlert('Azure Speech API 오류:\n' + azureValid.error, 'error');
                return;
            }

            // API 키 저장
            openaiKey = openai;
            azureKey = azure;
            azureRegion = region;

            localStorage.setItem('openai_api_key', openai);
            localStorage.setItem('azure_speech_key', azure);
            localStorage.setItem('azure_speech_region', region);

            document.getElementById('apiSettings').classList.add('hidden');
            showAlert('API 키가 검증되고 저장되었습니다', 'success');
        }

        // Azure Speech API 검증 (마이크 없이)
        async function validateAzureSpeechAPI(key, region) {
            try {
                const tokenUrl = `https://${region}.api.cognitive.microsoft.com/sts/v1.0/issueToken`;

                const response = await fetch(tokenUrl, {
                    method: 'POST',
                    headers: {
                        'Ocp-Apim-Subscription-Key': key,
                        'Content-Length': '0'
                    }
                });

                if (response.ok) {
                    return { success: true };
                } else if (response.status === 401) {
                    return {
                        success: false,
                        error: '잘못된 API 키입니다.\nAzure Portal의 Keys and Endpoint에서\nKey 1 또는 Key 2를 복사하세요.'
                    };
                } else if (response.status === 404) {
                    return {
                        success: false,
                        error: `리전이 잘못되었습니다: ${region}\n\n올바른 리전 예시:\n- koreacentral (한국 중부)\n- eastus (미국 동부)\n- westeurope (유럽 서부)\n\nAzure Portal에서 정확한 리전을 확인하세요.`
                    };
                } else {
                    return {
                        success: false,
                        error: `API 오류 (HTTP ${response.status})\n응답을 확인할 수 없습니다.`
                    };
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    return {
                        success: false,
                        error: '네트워크 오류:\n1. 인터넷 연결 확인\n2. 방화벽/VPN 확인\n3. CORS 정책 확인'
                    };
                }
                return {
                    success: false,
                    error: '검증 중 오류 발생:\n' + error.message
                };
            }
        }

        // API 설정 토글
        function toggleApiSettings() {
            const settings = document.getElementById('apiSettings');
            settings.classList.toggle('hidden');
            if (!settings.classList.contains('hidden')) {
                document.getElementById('openaiKeyInput').value = openaiKey;
                document.getElementById('azureKeyInput').value = azureKey;
                document.getElementById('azureRegionInput').value = azureRegion;
            }
        }

        // 용어집 패널 토글
        function toggleGlossary() {
            const panel = document.getElementById('glossaryPanel');
            panel.classList.toggle('hidden');
        }

        // 용어집 불러오기
        function loadGlossary() {
            const saved = localStorage.getItem('glossary');
            if (saved) {
                try {
                    const terms = JSON.parse(saved);
                    glossary = new Map(terms);
                } catch (e) {
                    console.error('용어집 불러오기 실패:', e);
                }
            }
        }

        // 용어집 저장
        function saveGlossary() {
            const terms = Array.from(glossary.entries());
            localStorage.setItem('glossary', JSON.stringify(terms));
        }

        // 용어 추가
        function addGlossaryTerm() {
            const termInput = document.getElementById('glossaryTermInput');
            const pronInput = document.getElementById('glossaryPronunciationInput');

            const term = termInput.value.trim();
            const pronunciationsStr = pronInput.value.trim();

            if (!term) {
                showAlert('정확한 용어를 입력해주세요', 'error');
                return;
            }

            // 발음을 배열로 변환
            const pronunciations = pronunciationsStr
                .split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            const key = term.toUpperCase();
            glossary.set(key, {
                term: term,
                pronunciations: pronunciations
            });

            saveGlossary();
            updateGlossaryList();

            termInput.value = '';
            pronInput.value = '';
            showAlert(`용어 추가됨: ${term} (${pronunciations.length}개 발음)`, 'success');
        }

        // 용어 삭제
        function removeGlossaryTerm(term) {
            glossary.delete(term);
            saveGlossary();
            updateGlossaryList();
            showAlert(`용어 삭제됨: ${term}`, 'info');
        }

        // 용어집 목록 업데이트
        function updateGlossaryList() {
            const listEl = document.getElementById('glossaryList');

            if (glossary.size === 0) {
                listEl.innerHTML = '<p style="color: #888888; font-size: 11px;">용어가 없습니다</p>';
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            glossary.forEach((data, key) => {
                const term = data.term;
                const pronunciations = data.pronunciations || [];
                const pronText = pronunciations.length > 0
                    ? pronunciations.join(', ')
                    : '발음 없음';

                html += `
                    <div style="background: #1a1a1a; padding: 10px; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="color: #4caf50; font-size: 13px; font-weight: bold;">${term}</span>
                            <button onclick="removeGlossaryTerm('${key}')" style="background: #ff5722; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">삭제</button>
                        </div>
                        <div style="color: #888888; font-size: 10px;">발음: ${pronText}</div>
                    </div>
                `;
            });
            html += '</div>';

            listEl.innerHTML = html;
        }

        // 텍스트 전처리 (발음을 정확한 용어로 치환)
        function preprocessText(text) {
            let processedText = text;
            let replacements = [];

            // 모든 용어집 항목에 대해 발음을 정확한 용어로 치환
            glossary.forEach((data) => {
                const correctTerm = data.term;
                const pronunciations = data.pronunciations || [];

                pronunciations.forEach(pronunciation => {
                    if (!pronunciation) return;

                    try {
                        // 정규식 특수문자 이스케이프
                        const escapedPron = pronunciation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

                        // 대소문자 구분 없이 치환
                        // 단어 경계를 사용하되, 한글은 단어 경계가 없으므로 공백/구두점으로 구분
                        const regex = new RegExp(`(^|\\s|[.,!?])${escapedPron}($|\\s|[.,!?])`, 'gi');

                        const newText = processedText.replace(regex, (match, before, after) => {
                            replacements.push(`"${pronunciation}" → "${correctTerm}"`);
                            return before + correctTerm + after;
                        });

                        processedText = newText;
                    } catch (e) {
                        console.error(`정규식 오류 (${pronunciation}):`, e);
                    }
                });
            });

            // 치환 내역 로그
            if (replacements.length > 0) {
                console.log('용어 교정:', replacements.join(', '));
                showAlert(`용어 교정: ${replacements.length}개`, 'info');
            }

            return processedText;
        }

        // Azure Speech SDK 초기화
        function initRecognition() {
            if (!azureKey || !azureRegion) {
                showAlert('먼저 Azure Speech API 키를 설정해주세요', 'error');
                toggleApiSettings();
                return false;
            }

            try {
                const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(azureKey, azureRegion);

                // 언어 설정
                translationDirection = document.getElementById('direction').value;
                speechConfig.speechRecognitionLanguage = translationDirection === 'ko-to-en' ? 'ko-KR' : 'en-US';

                const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
                recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

                // 실시간 인식 중 이벤트
                recognizer.recognizing = (s, e) => {
                    if (e.result.text && isListening) {
                        currentRecognizing = e.result.text;
                        handleRecognizing(e.result.text);
                    }
                };

                // 최종 인식 완료 이벤트
                recognizer.recognized = (s, e) => {
                    if (e.result.text && isListening) {
                        currentRecognizing = '';
                        handleRecognized(e.result.text);
                    }
                };

                // 에러 이벤트 - 개선된 에러 처리
                recognizer.canceled = (s, e) => {
                    console.error('Recognition canceled:', e);
                    console.error('Error Code:', e.errorCode);
                    console.error('Error Details:', e.errorDetails);
                    console.error('Reason:', e.reason);

                    if (e.reason === SpeechSDK.CancellationReason.Error) {
                        let errorMsg = '음성 인식 오류\n\n';

                        // StatusCode 1006 특별 처리
                        if (e.errorDetails && e.errorDetails.includes('1006')) {
                            errorMsg += 'WebSocket 연결 실패 (StatusCode: 1006)\n\n';
                            errorMsg += '가능한 원인:\n';
                            errorMsg += '1. API 키와 리전 불일치\n';
                            errorMsg += `   현재 리전: ${azureRegion}\n`;
                            errorMsg += '   Azure Portal에서 확인하세요\n\n';
                            errorMsg += '2. 잘못된 API 키\n';
                            errorMsg += '   Keys and Endpoint에서 Key 1 또는 Key 2 복사\n\n';
                            errorMsg += '3. 네트워크/방화벽 차단\n';
                            errorMsg += '   VPN 또는 회사 네트워크 확인';
                        } else {
                            errorMsg += e.errorDetails;
                        }

                        showAlert(errorMsg, 'error');

                        // 자동으로 중지
                        stopListening();
                    }
                };

                // 세션 시작 이벤트
                recognizer.sessionStarted = (s, e) => {
                    console.log('세션 시작됨:', e.sessionId);
                };

                // 세션 중지 이벤트
                recognizer.sessionStopped = (s, e) => {
                    console.log('세션 중지됨:', e.sessionId);
                };

                return true;
            } catch (error) {
                console.error('Azure Speech SDK 초기화 실패:', error);
                showAlert('Azure Speech SDK 초기화 실패: ' + error.message, 'error');
                return false;
            }
        }

        // 방향 변경
        function changeDirection() {
            const wasListening = isListening;
            if (wasListening) {
                stopListening();
            }
            history = [];

            // 캐시 초기화 (방향이 바뀌면 캐시 무효화)
            clearCache();

            // 화면 완전히 초기화 (이 경우에만 전체 재렌더링)
            const container = document.getElementById('subtitles');
            container.innerHTML = '<div class="subtitle-temp">발표 음성을 기다리는 중...</div>';

            if (wasListening) {
                setTimeout(() => startListening(), 500);
            }
        }

        // 음성 인식 시작
        function startListening() {
            if (!openaiKey || !azureKey || !azureRegion) {
                showAlert('먼저 API 키를 설정해주세요', 'error');
                toggleApiSettings();
                return;
            }

            if (isListening) return;

            // Recognizer 초기화
            if (!initRecognition()) {
                return;
            }

            isListening = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('status').textContent = 'LIVE';
            document.getElementById('status').classList.add('live');

            recognizer.startContinuousRecognitionAsync(
                () => {
                    console.log('음성 인식 시작됨');
                    showAlert('음성 인식 시작 - 마이크에 대고 말씀하세요', 'success');

                    // 초기 메시지 제거
                    const container = document.getElementById('subtitles');
                    const tempMsg = container.querySelector('.subtitle-temp');
                    if (tempMsg && tempMsg.textContent.includes('기다리는 중')) {
                        tempMsg.remove();
                    }
                },
                (err) => {
                    console.error('음성 인식 시작 실패:', err);

                    let errorMsg = '음성 인식 시작 실패\n\n';

                    if (err.toString().includes('microphone')) {
                        errorMsg += '마이크 권한 문제:\n';
                        errorMsg += '1. 브라우저 주소창 왼쪽의 마이크 아이콘 클릭\n';
                        errorMsg += '2. 마이크 권한 허용 선택\n';
                        errorMsg += '3. 페이지 새로고침 후 다시 시도';
                    } else if (err.toString().includes('NotFoundError')) {
                        errorMsg += '마이크를 찾을 수 없습니다:\n';
                        errorMsg += '1. 마이크가 연결되어 있는지 확인\n';
                        errorMsg += '2. 시스템 설정에서 마이크 활성화 확인\n';
                        errorMsg += '3. 다른 프로그램에서 마이크를 사용 중인지 확인';
                    } else {
                        errorMsg += err;
                    }

                    showAlert(errorMsg, 'error');
                    isListening = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('status').textContent = 'READY';
                    document.getElementById('status').classList.remove('live');
                }
            );
        }

        // 음성 인식 중지
        function stopListening() {
            if (!isListening || !recognizer) return;

            recognizer.stopContinuousRecognitionAsync(
                () => {
                    console.log('음성 인식 중지됨');
                    showAlert('음성 인식 중지', 'info');
                    recognizer.close();
                    recognizer = null;
                },
                (err) => {
                    console.error('음성 인식 중지 실패:', err);
                    showAlert('음성 인식 중지 실패: ' + err, 'error');
                }
            );

            isListening = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'READY';
            document.getElementById('status').classList.remove('live');
        }

        // 실시간 인식 중
        function handleRecognizing(text) {
            realtimeMode = document.getElementById('realtimeMode').checked;

            if (realtimeMode && text.length > 5) {
                // 디바운스를 사용하여 너무 자주 호출하지 않음
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    translateRealtime(text);
                }, 400);
            } else {
                updateSubtitles(text, null, false);
            }
        }

        // 최종 인식 완료
        function handleRecognized(text) {
            clearTimeout(debounceTimer);
            currentTranslating = '';

            // 스트리밍 블록 제거
            const streamingBlock = document.getElementById('subtitles').querySelector('.subtitle-streaming');
            if (streamingBlock) {
                streamingBlock.remove();
            }

            // 텍스트 전처리 (발음 교정)
            const correctedText = preprocessText(text);

            // 교정 내역 표시
            if (correctedText !== text) {
                console.log('원본:', text);
                console.log('교정됨:', correctedText);
            }

            updateSubtitles(null, null, true);
            translateAndAdd(correctedText);
        }

        // 실시간 번역
        async function translateRealtime(text) {
            try {
                // 텍스트 전처리 (발음 교정)
                const correctedText = preprocessText(text);

                // 선택된 번역 엔진 사용
                const translated = await translate(correctedText, true);
                currentTranslating = translated;
            } catch (error) {
                console.error('실시간 번역 오류:', error);
                updateSubtitles(null, '번역 오류', false);
            }
        }

        // 최종 번역 및 히스토리 추가
        async function translateAndAdd(text) {
            try {
                // 선택된 번역 엔진 사용
                const translated = await translate(text, false);

                // 스트리밍 완료 후 히스토리에 추가
                history.push({ source: text, translated: translated });
                currentTranslating = '';
                isStreaming = false;

                // 히스토리 블록 추가 (재렌더링 없이)
                addHistoryBlock(translated);
            } catch (error) {
                console.error('번역 오류:', error);
                const errorMsg = 'Translation Error';
                history.push({ source: text, translated: errorMsg });
                isStreaming = false;
                addHistoryBlock(errorMsg);
                showAlert('번역 오류가 발생했습니다', 'error');
            }
        }

        // 번역 (메인 인터페이스)
        async function translate(text, isRealtime) {
            return await translateWithOpenAI(text, isRealtime);
        }

        // 캐시 키 생성 (정규화)
        function getCacheKey(text, direction) {
            return `${direction}|${text.trim().toLowerCase()}`;
        }

        // 캐시에서 번역 조회
        function getFromCache(text, direction) {
            const key = getCacheKey(text, direction);
            if (translationCache.has(key)) {
                cacheHits++;
                console.log(`캐시 HIT: "${text}" → ${translationCache.get(key)}`);
                updateCacheStats();
                return translationCache.get(key);
            }
            cacheMisses++;
            updateCacheStats();
            return null;
        }

        // 캐시에 번역 저장
        function saveToCache(text, direction, translation) {
            const key = getCacheKey(text, direction);

            // 캐시 크기 제한 (오래된 항목부터 삭제)
            if (translationCache.size >= MAX_CACHE_SIZE) {
                const firstKey = translationCache.keys().next().value;
                translationCache.delete(firstKey);
                console.log(`캐시 용량 초과: 오래된 항목 삭제`);
            }

            translationCache.set(key, translation);
            updateCacheStats();
            console.log(`캐시 저장: "${text}" → "${translation}"`);
        }

        // 캐시 초기화
        function clearCache() {
            const size = translationCache.size;
            translationCache.clear();
            cacheHits = 0;
            cacheMisses = 0;
            updateCacheStats();
            console.log('캐시 초기화됨');
            showAlert(`캐시 초기화 완료 (${size}개 항목 삭제)`, 'info');
        }

        // 캐시 통계 업데이트
        function updateCacheStats() {
            const total = cacheHits + cacheMisses;
            const hitRate = total > 0 ? Math.round((cacheHits / total) * 100) : 0;
            const statsEl = document.getElementById('cacheStats');

            if (statsEl) {
                const cacheSize = translationCache.size;
                statsEl.textContent = `Cache: ${cacheHits}/${total} (${hitRate}%) | ${cacheSize} saved`;

                // 히트율에 따라 색상 변경
                if (hitRate >= 50) {
                    statsEl.style.color = '#4caf50'; // 초록색
                } else if (hitRate >= 20) {
                    statsEl.style.color = '#00bcd4'; // 파란색
                } else {
                    statsEl.style.color = '#888888'; // 회색
                }
            }
        }

        // OpenAI API 번역 (Streaming + Caching)
        async function translateWithOpenAI(text, isRealtime) {
            const direction = document.getElementById('direction').value;

            // 1. 캐시 확인 (즉시 반환)
            const cached = getFromCache(text, direction);
            if (cached) {
                // 캐시된 결과를 스트리밍처럼 표시 (빠르게)
                if (!isRealtime) {
                    isStreaming = true;

                    // 한 글자씩 추가 (매우 빠르게)
                    for (let i = 0; i < cached.length; i++) {
                        currentStreamingText = cached.substring(0, i + 1);
                        updateSubtitles(null, currentStreamingText, false);
                        await new Promise(resolve => setTimeout(resolve, 8));
                    }

                    isStreaming = false;
                }
                return cached;
            }

            // 2. 캐시 미스 - OpenAI API 호출
            // 최근 맥락 구성 (실시간은 컨텍스트 생략으로 속도 향상)
            let contextText = '';
            if (!isRealtime) {
                const recentHistory = history.slice(-2);
                if (recentHistory.length > 0) {
                    contextText = '\nPrevious context:\n';
                    recentHistory.forEach((item, i) => {
                        if (direction === 'ko-to-en') {
                            contextText += `${i+1}. KO: ${item.source}\n   EN: ${item.translated}\n`;
                        } else {
                            contextText += `${i+1}. EN: ${item.source}\n   KO: ${item.translated}\n`;
                        }
                    });
                }
            }

            let prompt;
            if (direction === 'ko-to-en') {
                prompt = `Translate this Korean veterinary presentation to professional English. Use proper veterinary terms. Output ONLY the English translation:${contextText}

${text}`;
            } else {
                prompt = `Translate this English veterinary presentation to professional Korean. Use proper Korean veterinary terms. Output ONLY the Korean translation:${contextText}

${text}`;
            }

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${openaiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.0,
                    max_tokens: isRealtime ? 60 : 150,
                    stream: true
                })
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            // 스트리밍 응답 처리
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullText = '';

            isStreaming = true;
            currentStreamingText = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const json = JSON.parse(data);
                            const content = json.choices[0]?.delta?.content || '';
                            if (content) {
                                fullText += content;
                                currentStreamingText = fullText;
                                // 실시간으로 UI 업데이트
                                updateSubtitles(null, currentStreamingText, false);
                            }
                        } catch (e) {
                            // JSON 파싱 오류 무시
                        }
                    }
                }
            }

            isStreaming = false;
            currentStreamingText = '';

            const finalText = fullText.trim();

            // 3. 번역 결과를 캐시에 저장
            saveToCache(text, direction, finalText);

            return finalText;
        }

        // 자막 업데이트 (깜박임 완전 제거)
        function updateSubtitles(recognizing = null, translating = null, isTranslating = false) {
            const container = document.getElementById('subtitles');

            // 1. 스트리밍 중이면 스트리밍 블록만 업데이트 (히스토리 건드리지 않음)
            if (isStreaming && translating) {
                let streamingBlock = container.querySelector('.subtitle-streaming');
                if (!streamingBlock) {
                    // 기존 임시 블록들만 제거 (히스토리는 유지)
                    removeTempBlocks(container);

                    streamingBlock = document.createElement('div');
                    streamingBlock.className = 'subtitle-streaming';
                    streamingBlock.dataset.length = '0'; // 현재 길이 추적
                    container.appendChild(streamingBlock);
                }

                // 이미 표시된 부분은 건드리지 않고 새로운 부분만 추가
                const currentLength = parseInt(streamingBlock.dataset.length || '0');
                const newText = translating.substring(currentLength);

                if (newText) {
                    const textNode = document.createTextNode(newText);
                    streamingBlock.appendChild(textNode);
                    streamingBlock.dataset.length = translating.length.toString();
                }

                container.scrollTop = container.scrollHeight;
                return;
            }

            // 2. 임시 블록들만 제거/업데이트 (히스토리 유지)
            removeTempBlocks(container);

            // 3. 현재 상태 표시 (새 블록 추가)
            if (translating) {
                const block = document.createElement('div');
                block.className = 'subtitle-translating';
                block.textContent = translating;
                container.appendChild(block);
            } else if (isTranslating) {
                const block = document.createElement('div');
                block.className = 'subtitle-temp';
                block.textContent = translationDirection === 'ko-to-en' ? '번역 중...' : 'Translating...';
                container.appendChild(block);
            } else if (recognizing && !document.getElementById('realtimeMode').checked) {
                const block = document.createElement('div');
                block.className = 'subtitle-recognizing';
                block.textContent = recognizing;
                container.appendChild(block);
            }

            // 스크롤 하단으로
            container.scrollTop = container.scrollHeight;
        }

        // 임시 블록만 제거 (히스토리 블록은 유지)
        function removeTempBlocks(container) {
            const tempBlocks = container.querySelectorAll('.subtitle-streaming, .subtitle-translating, .subtitle-temp, .subtitle-recognizing');
            tempBlocks.forEach(block => block.remove());
        }

        // 히스토리에 새 블록 추가 (한 번만 렌더링)
        function addHistoryBlock(text) {
            const container = document.getElementById('subtitles');

            // 임시 블록들 제거
            removeTempBlocks(container);

            // 새 히스토리 블록 추가
            const block = document.createElement('div');
            block.className = 'subtitle-block';
            block.textContent = text;
            container.appendChild(block);

            // 스크롤 하단으로
            container.scrollTop = container.scrollHeight;
        }

        // 폰트 크기 업데이트
        function updateFontSize() {
            const size = document.getElementById('fontSize').value;
            const blocks = document.querySelectorAll('.subtitle-block, .subtitle-streaming');
            blocks.forEach(block => {
                block.style.fontSize = size + 'px';
            });
        }

        // 알림 표시
        function showAlert(message, type = 'info') {
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.textContent = message;
            document.body.appendChild(alert);

            setTimeout(() => {
                alert.remove();
            }, 3000);
        }

        // ESC 키로 중지
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && isListening) {
                stopListening();
            }
        });
    </script>
</body>
</html>
